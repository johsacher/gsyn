#!/bin/bash
# still todo
# for now: gsyn_up after every change / gsyn_down when switching device
# --> no problems obeying SIMPLE RULE:
#     when switching machines:
#          when leaving old machine:
#               gsyn_up on old machine
#          when start working on new machine:   
#               gsyn_down on new machine

gsyn_up() {
    owd=$(pwd)
    path=$1
    if [[ ! -z "$path" ]] #not(!) empty(-z)
    then
        cd $path
    # else: do nothing, suppose we are in the right
    fi
    git add -A
    git commit -m '.'
    git push
    cd $owd
}

gsyn_down() {
    owd=$(pwd)
    path=$1
    if [[ ! -z "$path" ]]
    then
        cd $path
    # else: do nothing, suppose we are in the right
    fi
    git pull ;
    cd $owd
}



gsyn_up_all ()
{
    for repo in $(cat "$HOME/.gsyn/repositories") 
    do
        echo  ; echo  
        echo "synching up $repo..."
        echo "------------------------------------------"
        # expand home
        repo=$(echo $repo | sed 's|\~|'$HOME'|g')
        repo=$(echo $repo | sed 's|$HOME|'$HOME'|g')
        if [[ -d $repo ]] ; then
            gsyn_up $repo
        else
            echo "error: directory $repo does not exist, check ./gsyn/repositories"
        fi
    done
}

gsyn_down_all ()
{
    for repo in $(cat "$HOME/.gsyn/repositories") 
    do
        echo  ; echo  
        echo "synching down $repo..."
        echo "------------------------------------------"
        # expand home
        repo=$(echo $repo | sed 's|\~|'$HOME'|g')
        repo=$(echo $repo | sed 's|$HOME|'$HOME'|g')
        if [[ -d $repo ]] ; then
            gsyn_down $repo
        else
            echo "error: directory $repo does not exist, check ./gsyn/repositories"
        fi
    done
}


#* checkin/checkout - abstraction level
#  (at this level the user "just" checks in / checks out machines, and should not encounter any merging conflicts)
#  (since the idea of check-in/out system: only one machine at a time can work on the most current state of the projects)
#  (only necessary commands than are:
#  >> gsyn_checkin
#  >> gsyn_checkout

set_GSYN_THIS_MACHINE_NAME ()
{
    if [[ -f "$HOME/.gsyn/this_machine_name" ]] ; then
        GSYN_THIS_MACHINE_NAME=$(cat $HOME/.gsyn/this_machine_name)
    else
        echo "error: file $HOME/.gsyn/this_machine_name does not exist, add it and put some machine name of your choice there in the first line."
    fi

    # bash does not have the concept of return arguments... it is after all a primitive language. but: all variables are shared with calling environment ->
    # --> so work flow in bash is like this: we do not "give back" return parameters, insteady we "fill" global environment variables! (here: GSYN_THIS_MACHINE_NAME)
}

set_GSYN_CHECKED_IN_MACHINE ()
{
    if [[ -f "$HOME/.gsyn/checked_in_machine" ]] ; then
        GSYN_CHECKED_IN_MACHINE=$(cat $HOME/.gsyn/checked_in_machine)
    else
        echo "error: file $HOME/.gsyn/checked_in_machine does not exist, add it and put some machine name of your choice there in the first line."
    fi

    # bash does not have the concept of return arguments... it is after all a primitive language. but: all variables are shared with calling environment ->
    # --> so work flow in bash is like this: we do not "give back" return parameters, insteady we "fill" global environment variables! (here: GSYN_THIS_MACHINE_NAME)
}


set_checked_in_machine_this_machine ()
{
    set_GSYN_THIS_MACHINE_NAME
    echo $GSYN_THIS_MACHINE_NAME > $HOME/.gsyn/checked_in_machine
}

set_checked_in_machine_none ()
{
    echo "none" > $HOME/.gsyn/checked_in_machine
}

gsyn_checkout ()
{
    #* first check if i am allowed to checkin (requires checked_in_machine to be "none")
    gsyn_down $HOME/.gsyn # this just updates(uploads) the ~/.gsyn/checked_in_machine -> see if other machine is checked in
    set_GSYN_CHECKED_IN_MACHINE
    set_GSYN_THIS_MACHINE_NAME

    #* 3 scenarios: (1) none checked in ; (2) already checked in ; (3) other machine checked in

    #** scenario (1) none
    if [[ $GSYN_CHECKED_IN_MACHINE = "none" ]] ; then
        echo "Currently checked in machine to gsyn: none. --> already checked out."

    #** scenario (2) checked in
    elif [[ $GSYN_CHECKED_IN_MACHINE = $GSYN_THIS_MACHINE_NAME ]] ; then
        echo "This machine $GSYN_THIS_MACHINE_NAME is currently checked in and will be checked out now..."
        #*** check in this machine
        echo "    update(upload) server..."
        echo "    ------------------------------------"
        echo "    ------------------------------------"
        gsyn_up_all # (just in case) get up-to-date state of projects 
        #*** when successfully uploaded -> "officially check out"
        set_checked_in_machine_none # writes "none" to ~/.gsyn/checked_in_machine -> to tell other machines that they are allowed to checkin
        gsyn_up $HOME/.gsyn # this just updates(uploads) the ~/.gsyn/checked_in_machine -> visible for other machines
        echo "... Machine checked out successfully out off gsyn."

    #** scenario (3) already other machine
    else
        echo
        echo
        echo "Other machine already/still checked in, with machine name:"
        echo "    $GSYN_CHECKED_IN_MACHINE  "
        echo "check in not allowed! --> check out other machine first!"
    fi
}

gsyn_checkin ()
{
    #* first check if i am allowed to checkin (requires checked_in_machine to be "none")
    gsyn_down $HOME/.gsyn # this just updates(uploads) the ~/.gsyn/checked_in_machine -> see if other machine is checked in
    set_GSYN_CHECKED_IN_MACHINE
    set_GSYN_THIS_MACHINE_NAME

    #* 3 scenarios: (1) none checked in ; (2) already checked in ; (3) other machine checked in

    #** scenario (1) none
    if [[ $GSYN_CHECKED_IN_MACHINE = "none" ]] ; then
        echo "Currently checked in machine to gsyn: none. --> check in this machine $GSYN_THIS_MACHINE."

        #*** check in this machine
        gsyn_down_all # get up-to-date state of projects
        set_checked_in_machine_this_machine # writes <this_machine_name> to ~/.gsyn/checked_in_machine -> to tell other machines that they are NOT allowed to checkin
        gsyn_up $HOME/.gsyn # this just updates(uploads) the ~/.gsyn/checked_in_machine -> visible for other machines

        echo "... Machine $GSYN_THIS_MACHINE_NAME checked in successfully into gsyn."

    #** scenario (2) already checked in
    elif [[ $GSYN_CHECKED_IN_MACHINE = $GSYN_THIS_MACHINE_NAME ]] ; then
        echo "This machine $GSYN_THIS_MACHINE_NAME is already checked in into gsyn."
        #*** check in this machine

        echo "     just for safety perform gsyn_down_all..."
        echo "------------------------------------------"
        echo "------------------------------------------"
        gsyn_down_all # (just in case) get up-to-date state of projects 
        set_checked_in_machine_this_machine # writes <this_machine_name> to ~/.gsyn/checked_in_machine -> to tell other machines that they are NOT allowed to checkin
        gsyn_up $HOME/.gsyn # this just updates(uploads) the ~/.gsyn/checked_in_machine -> visible for other machines

        echo "... Machine $GSYN_THIS_MACHINE_NAME checked in successfully into gsyn."

    #** scenario (3) already other machine
    else
        echo
        echo
        echo "Other machine already/still checked in, with machine name:"
        echo "    $GSYN_CHECKED_IN_MACHINE  "
        echo "check in not allowed! --> check out other machine first!"
    fi
}


# some handy aliases (easier for command line, history completion)
in_gsyn ()
{
    gsyn_checkin
}

out_gsyn ()
{
    gsyn_checkout
}


# while :
# do
#     # todo: for all repos (get from file ~/.gsyn/repositories
#     sleep 20
#     echo "* checking if sync necessary (master ahead (1)/remote ahead (2)/diverged(3)?)..."

#     echo "* remote ahead (1) --> sync down..."
#     # gsyn_down

#     echo "* local ahead (2) --> sync up..."
#     # gsyn_up

#     echo "* diverged (3) --> more difficult --> try to merge..."

# done

#blabla
# blabla2
# bla3
